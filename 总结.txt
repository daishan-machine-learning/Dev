#pragma once
// preprocess -> compile -> obj file（中间文件） -> linker -> excutable file


// 1.可以按ctrl+F7对单个文件编译
// 2.错误列表是个垃圾，只能当作overview，输出列表才可以真正的找到错误所在
// 3.要特别关注项目的属性
// 4.区分编译错误和链接错误
// 5.只要我们不调用函数，那么函数的定义存在与否都不会引起link error
// 6.但是如果我们在一个函数f内部调用了s函数，即使我们没使用f，link error也会发生，因为链接器认为，即使我们不在当前文件(实际上应该是translation unit)调用，也可以能在其他地方调用
// 7.我们可以将f函数声明为static来确认该函数只在当前文件调用
// 8.函数定义不能放在header文件中，有可能导致代码的重定义 link error，但是也有替代的方法，我们可以使用static或者inline修饰该函数，这样就可以避免重定位。
// 9.variables 唯一需要记住的不同变量之间的区别就是:变量所占内存空间的大小
// 10.function is basic
// 11.debug 断点读取内存 ：breakpoints read memory


// 12.constant folding:常量折叠
// Expressions with constant operands can be evaluated at compile time, 
// thus improving run-time performance and reducing code size by avoiding evaluation at compile-time.
// 13.conditional statements are :if and else,no else if

// 14.通过项目属性设置文件的输出位置，显式文件:显式磁盘上文件的分布  不显示文件:显式逻辑上项目的文件分布
// 15.loops 有三种：for  while  do-while
// 16.control flows have three :continue,break,return 
// 17.指针，对于指针来说，指针的类型并不决定指针所存储的地址，指针所存储的地址和指针是int型还是double型都无关，但是指针的类型是影响我们操作数据的，当我们读取或者写内存的时候，
// 指针类型会决定我们可以读写多少字节，一般来说，int是4字节，double是8字节,我们可以动态的申请内存，例如 char* buffer = new char[8]; //这动态申请了8个字节的内存空间
// 18.reference:引用是变量的别名，它没有指针那么强大，但是一些情况下，它会更加简洁，引用需要明白的点:引用必须在建立时就初始化，且只能初始化一次
// 19.class:是数据和函数的集合
// 20.struct 和 class 唯一的区别就是默认情况下，struct的访问权限是public，class是private
// 21.虽然struct和class的区别很小，但是在我们的主观意识里面，还是有一些区别，比如:1.struct用来组织数据，且只组织数据 2.如果需要继承，我们不会使用struct，因为我们想保证struct的简单性

// 22.static有两个意义:1.在class的外部，表示限制static修饰的变量和函数只在当前translation unit内可见,有点像class中的private的作用  2.在class的内部，如果static修饰的是变量，
// 那么我们必须在类的外部定义变量，当我们访问的时候，可以通过实例访问，也可以通过类名::变量 的方式访问。如果类内部的static修饰的是函数，那么该函数在也只有一个，由于类的工作机制，每一个类内函数，
// 在被调用时，都会传入实例的对象，但是static函数，是不会传入对象的，所以static函数无法访问类内部的普通变量，static函数只能访问类的static变量和static函数。
// local静态变量产生后，它就会一直存在，直到程序结束，它和全局变量不同的是，它的scope(访问范围)只是local scope。这种想法其实可以很好的使用，比如单例模式。

// 23.除非你愿意将变量和函数跨traslation  unit，否则就把它们声明为static
// 24.enum 本质上就是一堆”整数”的组合，我们将这些数绑定成一组，enum的对象只能取这些数中的一个。注意：我们可以指定enum的数据类型,enum并不能像class那样作为一个命名空间使用，所以我们应该把
// 它看作是组合在一起的整数集合

// 25.constructor是一个没有返回值，函数名和类名一样的初始化函数，C++编译器虽然会给默认的构造函数，但是它什么都不会做，我们需要手动的初始化我们的数据，我们可以手动的删除编译器给我们
// 的默认constructor  类名() = delete; 就可以。我们也可以把构造函数设为私有，这样就没法访问构造函数了。
// 有一点是特别需要注意的，那就是heap allocation,当我们使用new关键词的时候，会自动调用constructor。如果我们一直使用static成员函数的化，constructor永远不会被调用。

// 26.destructor 是我们在退出栈或堆空间时，调用的清理操作，注意，这个函数必须被正确调用，不然会导致memory leak

// 27.copying & copy constructor:将数据或者对象从一个位置，复制到另一个位置的操作，叫做拷贝，这之间一定涉及两个不同的内存空间。什么样的场景叫做copy??
// 除了引用以外，只要我们将一个变量赋值(=)给另一个变量，我们就是在copy，只不过有的时候copy的是对象，有的时候是指针，有的时候是基本数据类型，这都无所谓，因为这都是copy，
	但是面对指针copy时，我们要格外小心。一般来说编译器会默认给我们一个拷贝构造函数，但是它的功能就是简单的shallow copy，所以当类中有指针时，我们应该重写copy constructor。
	也就是实现deep copy。
	编译器为我们实现的浅拷贝如下所示:
	String(const String& obj):m_buffer(obj.m_buffer),m_Size(obj.m_Size){
		
	}

// 28.Inhetritance使得子类继承了父类的数据，也就是说子类相当于包含了两个类型，子类和父类，可以通过sizeof看到子类的内存大小，以此验证说法。同时，由于子类拥有了父类的能力，那么，在
	每个调用父类类型的地方，都可以使用子类，因为子类继承了这些，这就构成了多态。

// 29.虚函数，如果我们在父类中对某个函数标记为virtual function，那么我们就拥有了在子类中对该函数重写的权力。
	1.使用virtual会告诉编译器，当前基类的函数需要建立一个虚表，以便如果它被重写，你可以调用正确的函数。这个叫做dynamic dispatch
	2.在c++11往后，子类中想要重写基类的同名函数，需要加上override，这有两个好处，1:增加可读性，2如果不小心把函数名写错，或者基类的函数不允许重写，那么编译器就会报错，父类函数不可重写
	3.使用virtual会产生两个cost，一个是内存代价，存储虚表需要额外的空间，二是运行代价，运行时需要访问虚表，以确定究竟该执行哪个函数。

// 30.pure viurtual function:纯虚函数，写纯虚函数的目的是强迫子类必须实现某些函数，如果子类不实现指定函数，那么就无法实例化，纯虚函数的强制性没有传递性，只到下一层就会停止。

// 31.C++只有三种访问权限 ：privte  protected public


// 32.数组：
		1.数组名的本质是指针
		2.指针+数字，移动多少要看指针的类型
		3.直接创建数组和使用new创建的数组一个在栈上，一个在堆上
		4.栈上数组与堆上数组的区别
			主要是生命周期的区别：栈上的数组在函数结束就会消失，但是堆上的数组如果不释放掉就会一直存在，造成内存泄露，需要使用delte[]解决
		5.在类中定义栈数组和堆数组的区别:memory direction & memory indirection
		6.标准库数组，std::array<type,size> arr;


// 33.const
	1.const int* data;
	2.int* const data;
		1，2-> const int* const p;
	3.const 函数
		本质
		有什么用  const对象
	4.float *x,*y; 和 float* x,y;的区别


// 34.mutable 
	1. 修饰变量，允许在const函数中改变mutable变量，这是最常用的用法
	2. 修饰lambda函数，允许对通过复制获取的变量的修改。这种用法并不常用。

// instantiate object
有两种方法,这两种方法归根结底是申请内存的不同方法:
1. stack
	使用stack的理由是，1.栈的分配很快， 2.栈的释放是自动完成
2. heap
	使用堆的理由是，1.栈的大小一般在1MB，如果我们需要分配很大的空间以至于超过栈本身的大小，程序要回崩溃。2.栈内存中对象的生命周期只在scope内，如果我们想
	获得生命周期超过scope的变量，那么我们需要使用堆
	堆不好的地方:
	1.分配速度很慢
	2.需要手动释放内存
///////////////////////////////// 堆栈详解/////////////////////////////////////////
预备知识―程序的内存分配 
一个由C/C++编译的程序占用的内存分为以下几个部分 

栈区（stack）― 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 
堆区（heap） ― 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 
全局区（静态区）（static）―，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量、未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放 
文字常量区 ―常量字符串就是放在这里的。程序结束后由系统释放 
程序代码区―存放函数体的二进制代码。
 一个正常的程序在内存中通常分为程序段、数据端、堆栈三部分。程序段里放着程序的机器码、只读数据，这个段通常是只读，对它的写操作是非法的。数据段放的是程序中的静态数据。动态数据则通过堆栈来存放。

 在内存中，它们的位置如下： 
+------------------+ 内存低端 
| 程序段 | 
|------------------| 
| 数据段 | 
|------------------| 
| 堆栈 | 
+------------------+ 内存高端 

 

 堆栈是内存中的一个连续的块。一个叫堆栈指针的寄存器（SP）指向堆栈的栈顶。堆栈的底部是一个固定地址。堆栈有一个特点就是，后进先出。也就是说，后放入的数据第一个取出。它支持两个操作，PUSH和POP。PUSH是将数据放到栈的顶端，POP是将栈顶的数据取出。
 在高级语言中，程序函数调用、函数中的临时变量都用到堆栈。为什么呢？因为在调用一个函数时，我们需要对当前的操作进行保护，也为了函数执行后，程序可以正确的找到地方继续执行，所以参数的传递和返回值也用到了堆栈。通常对局部变量的引用是通过给出它们对SP的偏移量来实现的。另外还有一个基址指针（FP，在Intel芯片中是BP），许多编译器实际上是用它来引用本地变量和参数的。通常，参数的相对FP的偏移是正的，局部变量是负的。 
 当程序中发生函数调用时，计算机做如下操作：首先把参数压入堆栈；然后保存指令寄存器(IP)中的内容，做为返回地址(RET)；第三个放入堆栈的是基址寄存器(FP)；然后把当前的栈指针(SP)拷贝到FP，做为新的基地址；最后为本地变量留出一定空间，把SP减去适当的数值。 

 在函数体中定义的变量通常是在栈上，用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区（静态区），在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用；在函数体内定义的static表示只在该函数体内有效。另外，函数中的"adgfdf"这样的字符串存放在常量区。

对比：

1 性能
栈：栈存在于RAM中。栈是动态的，它的存储速度是第二快的。stack
堆：堆位于RAM中，是一个通用的内存池。所有的对象都存储在堆中。heap

2 申请方式
stack【栈】: 由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 。
heap【堆】: 需要程序员自己申请，并指明大小，在c中malloc函数 如p1 = (char *)malloc(10); 在C++中用new运算符 如p2 = (char *)malloc(10); 但是注意：p1、p2本身是在栈中的。

3 申请后系统的响应
栈【stack】：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 

堆【heap】：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序；另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

4 申请大小的限制
栈【stack】：在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 

堆【heap】：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

5 申请效率的比较
栈【stack】：由系统自动分配，速度较快。但程序员是无法控制的。 

堆【heap】：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便. 
另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

6 堆和栈中的存储内容
栈【stack】：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 

 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
堆【heap】：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

7 存取效率的比较
char s1[] = "aaaaaaaaaaaaaaa"; 
char *s2 = "bbbbbbbbbbbbbbbbb"; 
aaaaaaaaaaa是在运行时刻赋值的； 而bbbbbbbbbbb是在编译时就确定的； 但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 
比如： 
#include 
void main() 
{ 
char a = 1; 
char c[] = "1234567890"; 
char *p ="1234567890"; 
a = c[1]; 
a = p[1]; 
return; 
} 
对应的汇编代码 
10: a = c[1]; 
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh] 
0040106A 88 4D FC mov byte ptr [ebp-4],cl 
11: a = p[1]; 
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h] 
00401070 8A 42 01 mov al,byte ptr [edx+1] 
00401073 88 45 FC mov byte ptr [ebp-4],al 
第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。 

小结： 
堆和栈的区别可以用如下的比喻来看出： 
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。



// 35.new keyword
	1.new的过程有两个:1.申请空闲空间  2.调用构造函数
	2.使用new必须对应的使用delete ，new[] 必须使用 delete[]
	3.new 和 new[] 不是同一个操作符
	4.如果我们要使用new[]生成一个类的对象数组，那么那个类必须有默认构造函数，因为new/new[]的第二步一定会调用构造函数


// 36.this
this 是指向当前对象的常指针 ,它的形式为 type* const this; this是成员函数被调用时默认且隐含传入的指针。

// 37.lifetiem
	1. 栈中的对象是scoped lifetime
	2. 堆中的对象的生命周期can live out the scope,但是需要我们手动的释放
	3. 我们可以使用scoped pointer使得堆上的对象自动释放。这是最简单的智能指针了。


// 38.智能指针
	std::nique_ptr<Entity> = std::make_unique<Entity>();
	// 智能指针是原始指针的包装
	//unique pointer是最简单的pointer，它是scope pointer，当超出当前的scope时，就会自动销毁，并调用delete
	// 智能指针都在memory头文件中
	//unique_ptr是不能拷贝的，因为当两个指针指向堆中同一个对象时，第一个指针释放完后，堆中数据已经被销毁。第二个指针释放的时候，就会导致memory leak
	//unique_ptr 的拷贝构造函数和赋值函数都被设置为delete
	// unique_ptr(const unique_ptr& ) = delete;
	// unique_ptr& operator=(const unique_ptr&) = delete;
	// shared_ptr 使用引用计数，允许我们进行拷贝和赋值
	// weak_ptr 和shared_ptr一样允许拷贝和赋值，但是不会增加shared_ptr的引用计数

	std::shared_ptr<Entity> entity = std::make_shared<Entity>(); // 允许拷贝和赋值
	智能指针有两种情况释放对象:
	1. 栈结束，调用析构函数释放对象
	1. 调用reset()函数，重新绑定新的对象，则原来的对象就会被释放。

	智能指针通过get函数返回原始指针
	关于shared_ptr 和 weak_ptr之间的关系:
	因为shared_ptr之间可能会构成死锁，所以我们使用weak_ptr,weak_ptr不能调用对象的成员函数，需要先lock().得到shared_ptr才能调用成员函数,而shared_ptr可以直接赋值给weak_ptr
	shared_ptr死锁例子:
	class A{
		public:
		shared_ptr<A> p;
	}
	int main(){
		shared_ptr<A> pa(new A());
		shared_ptr<A> pb(new B());
		pa->p = pb;
		pb->p = pa;
		//这个时候。两个指针的计数都为2，当释放pa时，计数变为1，资源不会释放，再释放pb，计数也变为1，也不会释放，导致死锁
	}



	// 39.operator arrow ->
	1.可以重写operator-> ，这种情况出现在自己写智能指针的情况，注意，可能我们想要const指针，这时候需要在operator->函数返回值上加上const，同时要把operator->变成const函数
	2.可以获取struct中变量的偏移offset
	struct Vec3{
		float x,y,z;
	};
	int main(){
		int offset = (int)&(((Vec3*)nullptr)->y); //获得变量y的偏移地址
	}

	// 40.vector 的优化工作
	1.使用reserve提前确定空间，避免resize的各种拷贝
	2.确定空间后，不再使用push_back，避免拷贝，可以使用emplace_back(),直接再已经确定的空间里面进行实例化，instantiate 

	// 41.static linking 静态链接 其它的库
		将头文件和lib文件包含的项目的目录中，注意对应的Solution和Platform